
도메인 연관관계에서 다대다 연관관계는 사용해서는 안됨.

* @JoinColumn을 꼭 사용해야함. 그렇지 않으면 조인 테이블 방식(중간 연결 테이블 추가.)을 사용함.
 (성능 / 유지 관리에 어려움이 있어 조인 테이블 방식을 사용하지 않음.)

* 연관관계 주인설정 시 혼란을 줄이기 위해,
  DB Table에 FK가 포함되어 있는 객체를 주인으로 설정함.
  (관계형 DB에서는 다대일인 경우 다 쪽에 FK를 포함한다. ->
    -> 반대의 경우 말이되지 않음. : Team / Member의 경우 Team에 FK(Member ID)를 포함하게되면,
     Member별로 Team을 추가해야하는 이상한 상황이 생김.)


* 일대 다 단방향(웬만하면 쓰면안됨.  - 객체와 업데이트 되는 테이블이 매칭되지 않아 혼란스러움.)
 - FK가 포함하지 않는 객체를 주인으로 설정하는 경우.
 - 일대다 관계만 필요하더라도, 다대일 양방향 관계를 만들어 혼란을 줄임.
  ( 객체지향 관점에서는 불필요한 관계가 연관관계가 생겨 안좋지만, 유지 보수 시 혼란을 줄이기때문에 선호됨.)

* 일대 다 양방향
 - 예제에 member쪽에 읽기전용으로 강제화 하는 방법이 있음. (어렵게... 이런매핑은 공식적으로 존재X)

* 일대일 관계
- 주 테이블이나 대상 테이블 중 외래키 선택가능.
- DB입장에서는 데이터베이스 유니크(UNI) 제약 조건 추가.
- 다대일 단방향과 유사함.

* 다대다 관계(사용하면 안됨 - 복잡도가 많이 증가하고 유지하기 힘듬.)
- 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능.
- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할수 없음.
  편법으로 연결테이블을 추가해서 일대다, 다대일 관계로 풀어내어야함.
   ex: Member(1) - (다)Member_Product(Member FK / Product FK) (다) - Product(1)
- Join Table사용.
- 다대다 한계극복 방법 -> 연결 테이블용 엔티티를 추가하여, 객체와 테이블을 동일하게 만듬.


양방향 연간관계의 경우 DB / 객체 지향 패러다음 사이에 차이가 있음.

- DB의 경우 하나의 FK를 이용하면 양방향 관계를 맺을 수 있음.
- 객체 양방향 관계를 위해 객체간 각각의 레퍼런스가 필요함.

JPA(ORM)의 경우, 객체지향 패러다임과 DB패러다임 사이에 연결을 해주어야하는데,
이때 양방향 관계 매핑을 처리하기 위한 연관관계 주인 개념이 필요하다.

객체지향의 경우 양방향 관계를 맺기 위해 각각의 레퍼런스를 가지고 있는데, 이때 주인을 정하지 않는 경우
어떤 기준으로 FK 를 관리할지 정할 수 없으므로 mappedby를 이용해 지정해야함.
* ex: 클래스 A / B가 아래와 같이 일대일 관계라고 했을때,
A a1 = new A;
A a2 = new A;
B b1 = new B;

//아래처럼 관계를 설정하는 경우 jpa(ORM)이
 어느것을 기준으로 FK설정을 해야할지 알수 없음.
 서로 다른 객체를 참조하고 있음. 이 때 연관관계 주인을 정해주게 되면,
 명확하게 어느 객체를 기준으로 FK설정을 할지 정할 수 있게됨.
b1->setA(a1);
a2->setB(b1);
class A {
 B refB;
 }

class B {
 A refA;
 }


----
상속관계
- 객체의 상속구조와 DB의 슈퍼타입 서브타입 관계를 매핑.
- 기본적으로 DB는 상속을 지원하지 않으므로 3가지 타입에 매핑방식이 있음.
 * Join 방식 ( 자식 클래스와 부모클래스의 Table생성 ) - 기본적으로 이걸 추천
   - 테이블 정규화가 되어있음/ 저장공간 효율화 / 외래키 참조 무결성 제약조건 활용가능.(null 비허용)
   - 조회시 조인을 많이 사용, 성능저하 / 조회 쿼리가 복잡함. / 테이블 저장시 INSERT SQL 2번 호출.
 * 단인테이블 방식(모든 자식 클래스를 포함한 하나의 Table생성)
   - 조인이 필요없으므로 일반적으로 조회성능이 빠름. / 조회 쿼리가 단숨함.
   - 자식 엔티티가 매핑한 컬럼은 모두 null 허용해야함 / 단일 테이블에 모든것을 저장하므로 테이블이 커질수 있음. 상황에 따라 느려질수도 있음.
 * 구현 클래스마다 테이블 전략( 비추 )
   - 서브 타입을 명확하게 구분해서 처리할 때 효과적 / not null 제약 조건 사용가능.
   - 여러자식 테이블을 ㅎ마께 조회할 때 성능이 느림.(UNION SQL) / 자식 테이블을 통합해서 쿼리하기 어려움.( Book book = em.find(Item.class, book->getid()); )

MappedSuperclass
- DB에는 부모 클래스에 대한 테이블을 생성하지 않고, 객체에서만 상속기능을 활용하도록 부모클래스에 어노테이션 적용.

----
프록시
- Member를 조회할 때 Team도 바로 조회해야할까?
  비즈니스 로직에서 Member값만 출력이 필요하는 경우: 굳이 DB에서 Team까지 가지고 올 필요가 없음.
  비즈니스 로직에서 Membmer-Team 모두 출력이 필요하는 경우: Team까지 바로 가지고 오는게 좋음.

 em.find : 데이터베이스를 통해 실제 엔티티 객체 조회
 em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

* 프록시 사용전 프록시를 영속성 context에서 제거하면 문제발생함.(프록시에서 결국 영속성컨텍스트에 요청해서 객체를 받아오므로 ..)
            Member member1 = new Member();
            member1.setName("aab");
            em.persist(member1);

            em.flush();
            em.clear();

            Member refMember = em.getReference(Member.class, member1.getId());
            System.out.println("test");
            em.detach(refMember);
            System.out.println(refMember.getName());
* 아래 케이스는 문제 안됨.
            Member member1 = new Member();
            member1.setName("aab");
            em.persist(member1);

            em.flush();
            em.clear();

            Member refMember = em.getReference(Member.class, member1.getId());
            System.out.println("test");
            System.out.println(refMember.getName());
            em.detach(refMember);
            System.out.println(refMember.getName());

  -------------------

  JPQL
  - 복잡한 조건의 조회를 위하여 SQL과 같은 언어가 필요함. => JPQL
   (JPA의 단순한 PK ID를 이용한 단일 조회나 객체 그래프에 의한 조회(a.getB().getC() )가 아닌
    특정 조건에 해당하는 객체들의 조회를 원할 경우. -> 월급 170만원 이상인 사용자 조회 )

    동적쿼리: 프로그램이 수행되면서 특정한 조건에 맞추어 쿼리문을 변경하는 방식 => 단순 문자열을 사용하게 되면 에러를 유발하거나 유지 보수가 힘듬.
     => JPA Criteria(JPA에서 지원) . Criteria의 경우 실수를 줄여줄 수있으나 쿼리문과 너무 동떨어져있어 유지 관리하기 어려움. =>
      QueryDSL(Opensource)을 사용함(쿼리문과 흡사하고 단순 문자열에 따른 동적쿼리 실수를 막아줌).

    간혹 특정 DB에 맞는 네이티브 SQL을 사용해야하는데, JPA는 네이티브 SQL을 사용하도록 지원해줌.
    JPA와 별도로 JDBC API를 직접이용하거나 MyBatis/SpringJdbcTemplate와 함께사용할 수 있음.( JPA와 함께사용시 영속성 관리 타이밍 주의해야함.)


    JPQL문법
    ex: select m from Member as m where m.age > 18
    엔티티와 속성은 대소문자 구분 / JPQL 키워드는 대소문자 구분X( SELECT / FROM /where ..)
    엔티티 이름 사용, 테이블 이름이 아님.
    별칭은 필수(as는 생략가능)

    TypeQuery / Query


    경로 표현식( 각 종류에 따라 sql 처리방식이 달라짐. )
    - 상태필드 ( m.username ) 단순히 값을 저장하기 위한 필드 -> 경로탐색의 끝. 추가 탐색이 필요없음.
      =>select m.username From Member m

    - 연관필드 : 연관관계를 위한 필드 ( **실무에서는 명시적 join을 사용해야함 이 후 튜닝하기 힘듬.) (묵시적으로는 내부조인만 발생됨.)
     -- 단일값 연관 필드( @ManyToOne , @OneToOne, 대상이 엔티티(m.team)  -> 묵시적 내부조인(inner join) 발생. 추가 탐색 가능.
      => select m.team From Member m (실무에서 조심해야함. 쿼리 튜닝할때 힘듬. jpql과 sql이 최대한 비슷하게 나가도록 만듬..)
     -- 컬렉션 값 연관필드 (@OneToMany, @ManyToMany, 대상이 컬렉션(ex:m.orders) -> 묵시적 내부조인 발생. 추가 탐색 불가.
      =>  select t.members From Team t / select m.username From team t join t.members m (명시적 내부조인을 통해 탐색 가능.)
     ***** 조인은 SQL 튜닝에 중요포인트임.

    ****** 패치조인 ********* (실무에서 꼭 사용해야함/ 없으면 실무가 안됨.)
    - SQL 조인 종류가 아님
    - JPQL에서 성능최적화를 위해 제공하는 기능.
    - 연관된 엔티티나 컬렉션을 SQL 한번에 함께 조회하는 기능.
    - join fetch 명령어 사용.
    ex: (jpql에서는 select m만 적었으나 변환된 SQL에서는 T까지 불러옴 - 즉시로딩과 동일 / 즉시로딩과의 차이는 명시적으로 컨트롤 가능한 부분임. )
      JPQL : select m from Member m join fetch m.team
      => SQL: select M.* , T.* From MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID

    컬렉션 패치 조인
    - 일대다 관계
   ex:
     JPQL : select t from Team t join fetch t.memebers where t.name = '팀A'
     => SQL : select T.* , M.* FROM TEAM T INNER JOIN MEMBER M ON T.ID=M.TEAM_ID WHERE T.NAME = '팀A'

     * 일대다 조인은 데이터가 뻥튀기 될수있음. ( ex: 회원1 -> 팀A , 회원2 -> 팀A => 팀A 조회시 결과 list의  실제 팀은 1(동일객체)이지만 size는 2임. )
     => 중복삭제를 위해서는 DISTINCT를 사용해야함. (SQL에 DISTINCT를 추가. + 애플리케이션에 엔티티 중복 제거. )
       (sql distinct는 모든 값이 똑같은 경우에 한해서만 중복을 제거해줌.
